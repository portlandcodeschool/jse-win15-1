{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\froman\fprq2\fcharset0 Courier New;}{\f1\froman\fprq2\fcharset0 Liberation Serif;}{\f2\fnil\fcharset0 Courier New;}{\f3\fnil\fcharset0 Courier;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 6.3.9600}\viewkind4\uc1 
\pard\nowidctlpar\kerning1\f0\fs22\lang1033 ### Homework #1\f1\fs24\par
\f0\fs22 (Due Monday 1/12)\f1\fs24\par
\f0\fs22\par
You need to turn in this homework by cloning this repo, making a new branch with your solutions, pushing to github, and issuing a pull request.\f1\fs24\par
\f0\fs22 For details, follow the instructions [here]({{\field{\*\fldinst{HYPERLINK http://portlandcodeschool.github.io/jse/2015/01/07/command-line-and-git-slides/#/14 }}{\fldrslt{http://portlandcodeschool.github.io/jse/2015/01/07/command-line-and-git-slides/#/14\ul0\cf0}}}}\f0\fs22 ).\f1\fs24\par
\f0\fs22\par
Please also read the [learning objectives](objectives.md) for this week.\f1\fs24\par
\f0\fs22\par
---\f1\fs24\par
\f0\fs22\par
**1)** (_Difficulty: mixed_)\f1\fs24\par
\f0\fs22 Predict the output of each of the following expressions, and explain the rules which determine it.\f1\fs24\par
\f0\fs22 If the output depends on the value of x, identify the conditions when the expression will output true.  Assume the cases are independent, and x is reset to an unknown value before each.\f1\fs24\par
\f0\fs22\par
Some of these are tricky!  Don't trust your first instinct.  \f1\fs24\par
\f0\fs22\par
\par
**a)** `"1" == 1`\f1\fs24\par
\f0\fs22 True: The string "1" is close enough to the number 1\f1\fs24\par
\f0\fs22\par
**b)** `"1" === 1`\f1\fs24\par
\f0\fs22 False: The string "1" is not equivalent to the number 1\f1\fs24\par
\f0\fs22\par
**c)** `x == 'x'`\f1\fs24\par
\f0\fs22 True if the variable x is equal to the string x, False otherwise because variable x is not the same as string \ldblquote x\rdblquote .\f1\fs24\par
\f0\fs22\par
**d)** `x == (x+'')`\f1\fs24\par
\f0\fs22 True because the variable x is close enough to (x+' '), it is x plus a string of space.\f1\fs24\par
\f0\fs22\par
**e)** `'' == ' '`\f1\fs24\par
\f0\fs22 False because the string of one space is not the same as the string of two spaces.\f1\fs24\par
\par
\f0\fs22\par
**f)** `x = true`\f1\fs24\par
\f0\fs22 True, This assigns x to be true, we could input x=false and get output false if that's what we want\f1\fs24\par
\f0\fs22\par
**g)** `var x; x == 'undefined'`\f1\fs24\par
\f0\fs22 False, x is not equal to the string \ldblquote undefined\rdblquote\f1\fs24\par
\par
\f0\fs22\par
**h)** `'9'<'10'`\f1\fs24\par
\f0\fs22 False, the string \ldblquote 9\rdblquote  is being compared to the string \ldblquote 1\rdblquote  (as the first number in the string \ldblquote 10\rdblquote ) for example \ldblquote 500\rdblquote <\rdblquote 60\rdblquote  is true because it is only comparing the first number in each string\f1\fs24\par
\par
\f0\fs22\par
**i)** `typeof x + 1 === "number"`\f1\fs24\par
\f0\fs22 False, even if x is a number, and adding 1 to it is a number, the type of x plus 1 is not itself a number.\f1\fs24\par
\f0\fs22\par
**j)** `typeof x % 2 === "number"`\f1\fs24\par
\f0\fs22 Fasle, x%2 is not equivalent to the string \ldblquote number\rdblquote .because the math will not be performed\f1\fs24\par
\f0\fs22\par
**k)** `typeof (x % 2) === "number"`\f1\fs24\par
\f0\fs22 True, The parenthesis tell the console to do the math first, then compare typeof the result, to see if it's a number.\f1\fs24\par
\f0\fs22\par
**l)** `x++ == ++x`\f1\fs24\par
\f0\fs22 False, x++ results in the value of x plus whatever comes next, while ++x takes whatever number to add to x, making x the last step in the addition.\f1\fs24\par
\f0\fs22\par
**m)** `++x == x++`\f1\fs24\par
\f0\fs22 True, ++x is added up, then compared to x(which is the result of ++x)then the remaining ++ will be used for the next line. Example x+x+x=3 compare to   new x which is now 3, (output:true) then +x+x is evaluated.\f1\fs24\par
\par
\f0\fs22\par
**n)** `"1"+x == 1+x`\f1\fs24\par
\f0\fs22 False, the string \ldblquote 1\rdblquote  plus whatever x is will just slide the string\rdblquote 1\rdblquote  in front of x, not add 1+x as math. Ex: say x = 24, \ldblquote 1\rdblquote +x = 124, while 1+x = 25.\f1\fs24\par
\f0\fs22\par
**o)** `"0"+1 == 1`\f1\fs24\par
\f0\fs22 True(mostly), The output will be \ldblquote 01\rdblquote  which is the same number as 1, but not the exact same as 1\f1\fs24\par
\f0\fs22\par
**p)** `(typeof (x+1))===(typeof x)`\f1\fs24\par
\f0\fs22 True, (x+1) is evaluated, then that result is now x, so now you're comparing  (typeof x)===(typeof x) which is true.\f1\fs24\par
\f0\fs22\par
**q)** `(x*1 == x) || ((typeof x) != "number")`\f1\fs24\par
\f0\fs22 True, One side of || will always be true, as long as one of the two statements is true\f1\fs24\par
\f0\fs22\par
**r)** `(x=(typeof (x+(typeof x))))==x`\f1\fs24\par
\f0\fs22 True, The typeof x operators will result in x, making x==x, makingit true.\f1\fs24\par
\f0\fs22\par
---\f1\fs24\par
\f0\fs22\par
All of the following can be solved with ordinary expressions and global variables with primitive values.  You don't need functions, loops, or other topics beyond our first two classes.\f1\fs24\par
\f0\fs22\par
 **2)** (_Difficulty: easy_)\f1\fs24\par
\f0\fs22\par
Assume variables x, y, and z are numbers.\f1\fs24\par
\f0\fs22\par
**a)**\f1\fs24\par
\f0\fs22 Write an expression for the mean (i.e. average) of x, y, and z.\f1\fs24\par
\f0\fs22 var mean;\f1\fs24\par
\f0\fs22 mean = (x+y+z)\f1\fs24\par
\f0\fs22 mean = mean/3\f1\fs24\par
\par
\f0\fs22\par
**b)**\f1\fs24\par
\f0\fs22 Write a series of expressions to adjust each of x, y, and z halfway toward their mean.\f1\fs24\par
\f0\fs22 That is, reset the value of each variable to something based on its previous value.\f1\fs24\par
\par
\f0\fs22 Var mean;\f1\fs24\par
\f0\fs22 mean = (x+y+z)\f1\fs24\par
\f0\fs22 mean = mean /3\f1\fs24\par
\f0\fs22 x = mean-x\f1\fs24\par
\f0\fs22 x = mean / 2\f1\fs24\par
\f0\fs22 x = mean + x;\f1\fs24\par
\par
\f0\fs22 y = mean-y\f1\fs24\par
\f0\fs22 y = mean / 2\f1\fs24\par
\f0\fs22 y = mean + y;\f1\fs24\par
\f0\fs22\par
z = mean-z\f1\fs24\par
\f0\fs22 z = mean / 2\f1\fs24\par
\f0\fs22 z = mean + z;\f1\fs24\par
\par
\f0\fs22\par
**3)** (_Difficulty: easyish_)\f1\fs24\par
\f0\fs22\par
Suppose you're encoding geometric shapes in a Cartesian (2D) coordinate system, and you represent a rectangle with four numeric variables:\f1\fs24\par
\f0\fs22\par
- _l_ : horizontal position of left edge;\f1\fs24\par
\f0\fs22 - _r_ : horizontal position of right edge;\f1\fs24\par
\f0\fs22 - _t_ : vertical position of top edge;\f1\fs24\par
\f0\fs22 - _b_ : vertical position of bottom edge.\f1\fs24\par
\f0\fs22\par
**a)**\f1\fs24\par
\f0\fs22 Write an expression for the rectangle's area.\f1\fs24\par
\par
\f0\fs22 Var area;\f1\fs24\par
\f0\fs22 area = (r-l)*(b-t);\f1\fs24\par
\f0\fs22\par
\f1\fs24\par
\par
\par
\par
\par
\par
\par
\par
\f0\fs22 **b)**\f1\fs24\par
\f0\fs22 Write an expression which is true if the rectangle is taller than it is wide, and false otherwise.\f1\fs24\par
\par
\f0\fs22 Var width, height;\f1\fs24\par
\f0\fs22 width = (r-l);\f1\fs24\par
\f0\fs22 height = (t-b);\f1\fs24\par
\f0\fs22 if (width<height)\{\f1\fs24\par
\f0\fs22   console.log(\ldblquote true\rdblquote )\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\f0\fs22 else\{\f1\fs24\par
\f0\fs22   console.log(\ldblquote false\rdblquote );\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\f0\fs22\par
**c)**\f1\fs24\par
\f0\fs22 Write an expression for the circumference of the biggest circle which can fit inside the rectangle.  (Hint: you'll need logic similar to that in **b**.)\f1\fs24\par
\par
\f0\fs22 var width, height, radi, circ;\f1\fs24\par
\f0\fs22 width = (r-l);\f1\fs24\par
\f0\fs22 height = (t-b);\f1\fs24\par
\f0\fs22 if (width<height)\{\f1\fs24\par
\f0\fs22   radi = (width/2);\f1\fs24\par
\f0\fs22   circ = (2*Math.PI*radi);\f1\fs24\par
\f0\fs22   console.log(\ldblquote true\rdblquote );\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\f0\fs22 else\{\f1\fs24\par
\f0\fs22   console.log(\ldblquote false\rdblquote );\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\par
\f0\fs22\par
**d)**\f1\fs24\par
\f0\fs22 Write an expression for the area of the smallest circle which completely encloses (i.e. circumscribes) the rectangle.\f1\fs24\par
\par
\f0\fs22 var width, height, radi, circ, area;\f1\fs24\par
\f0\fs22 width = (r-l);\f1\fs24\par
\f0\fs22 height = (t-b);\f1\fs24\par
\f0\fs22 area = (r-l)*(b-t);\f1\fs24\par
\f0\fs22 radi = (area * 2);\f1\fs24\par
\f0\fs22\par
\f1\fs24\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\f0\fs22 **e)**\f1\fs24\par
\f0\fs22 Imagine subdividing your rectangle into 3 equal rows and 3 equal columns, which would create 9 smaller rectangles, identical in shape but varying by position.\f1\fs24\par
\f0\fs22 Define four new variables describing the centermost small rectangle.\f1\fs24\par
\f0\fs22 (_Hint: one of the many solutions is very similar to the solution of **2b** above._)\f1\fs24\par
\par
\f0\fs22 Var width, height, col1, col2, row1, row2;\f1\fs24\par
\f0\fs22 width = (r-l);\f1\fs24\par
\f0\fs22 height = (t-b);\f1\fs24\par
\f0\fs22 col1 = (width/3) + l;\f1\fs24\par
\f0\fs22 col2 = col1 + (width/3);\f1\fs24\par
\f0\fs22 row1 = (height/3)+t;\f1\fs24\par
\f0\fs22 row2 = row1 + (height/3);\f1\fs24\par
\par
\f0\fs22\par
\f1\fs24\par
\par
\f0\fs22 ---\f1\fs24\par
\f0\fs22\par
**4)** (_Difficulty: easyish_)\f1\fs24\par
\f0\fs22\par
Imagine that the squares of an ordinary checkerboard are numbered in two different ways:\f1\fs24\par
\f0\fs22\par
* Each square has integer coordinates _(R,C)_ describing its row and column.  Both values should be in the range 0..7, so that the upper-left square is at (0,0) and the bottom-right is at (7,7).\f1\fs24\par
\f0\fs22\par
* Each square has a unique integer number N from 0 to 63.  These numbers run sequentially left-to-right one row at a time, top to bottom.  Therefore the upper-left square has N==0 and the bottom-right has N==63.\f1\fs24\par
\f0\fs22\par
**a)**  Given a particular R and C, find the corresponding N.  That is, write an expression for variable N containing variables R and C.\f1\fs24\par
\par
\f0\fs22 N = (C*8)+R;\f1\fs24\par
\f0\fs22\par
**b)**  Given N, find R.  Write an expression for R which contains N.\f1\fs24\par
\f0\fs22\par
R = Math.floor (N/8);\par
\f1\fs24\par
\f0\fs22\par
**c)**  Given N, find C.  Write an expression for C which contains N.\f1\fs24\par
\par
\f0\fs22 C = N%8\f1\fs24\par
\f0\fs22\par
**d)**  Assume the squares are colored black and white, with the upper-left square black.\f1\fs24\par
\f0\fs22 Write an expression to set a variable _color_ to either 'black' or 'white', describing the square identified by variables R,C, and N.\f1\fs24\par
\f0\fs22 (_Hint: If you prefer, you may use a pair of conditional statements instead of a single expression._)\f1\fs24\par
\par
\f0\fs22 if ((R%2)=0)\{\f1\fs24\par
\f0\fs22   color = black;\f1\fs24\par
\f0\fs22\}else\{\f1\fs24\par
\f0\fs22   color = white\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\par
\f0\fs22 if ((N%2)=0\{\f1\fs24\par
\f0\fs22   color = black;\f1\fs24\par
\f0\fs22\}\f1\fs24\par
\f0\fs22 else\{\f1\fs24\par
\f0\fs22   color = white;\f1\fs24\par
\f0\fs22   \}\f1\fs24\par
\f0\fs22\par
---\f1\fs24\par
\f0\fs22\par
**5)** (_Difficulty: moderate_)\f1\fs24\par
\f0\fs22\par
Suppose you represent a fraction (_n/d_) with 2 integer variables: _n_ for the numerator and _d_ for the denominator.\f1\fs24\par
\f0\fs22 If _n_ is greater than _d_, the fraction is "improper", but it can be rewritten as a proper fraction.  For example, "7/4" is \f2 improper, but it can be rewritten as "1 3/4", which is proper.\par
\par
Write an expression for a string expressing the proper form of an improper fraction _n/d_.  For example, when _n==7_ and _d==4_, your resulting string should be "1 3/4".  You may assume both _n_ and _d_ are positive integers and _n_ > _d_, but otherwise you should be able to handle any values of _n_ and _d_.\par
(_Hint: you'll need the modulo operator _%_, and you'll probably want to create a couple of extra variables._)\par
\par
var wholeNumber, remainder, mixedFraction, n, d;\par
\par
\tab\tab\par
n=7\par
d=4\par
wholeNumber = Math.floor(n/d);\par
remainder = (n % d);\par
if (d == 0) \{\par
\tab\tab console.log("The result of dividing by 0 is", wholeNumber);\par
\tab\} \par
else\{\par
\tab\tab console.log("The answer =  ", wholeNumber, remainder + "/" + d);\tab\par
\tab\}\par
\par
\f3\par
}
 